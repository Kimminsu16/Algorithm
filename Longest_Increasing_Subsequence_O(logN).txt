// Longest Increasing Subesequence 알고리즘
// 시간복잡도가 O(logN)인 경우
// https://blog.naver.com/alstn3659/222655173238

#include <stdio.h>

int binarySearch(int *list, int left, int right, int target)
{
	int mid;
	while (left < right) {
		mid = (left + right) / 2;
		if (list[mid] < target) 
			left = mid + 1;
		else 
			right = mid;
	}
	return right;
}

int main()
{
	int A[8] = { 1, 4, 0, 3, 7, 2, 5, 10 };
	int A_X[8] = { };

	A_X[0] = 1;
	int j = 0;

	for (int i = 1; i < 8; i++)
	{
		if (A_X[j] < A[i])
		{
			A_X[j+1] = A[i];
			j++;
		}
		else
		{
			int pos = binarySearch(A_X, 0, j, A[i]);
			A_X[pos] = A[i];
		}
	}

	for (int i = 0; i < j + 1; i++) printf("%d ", A_X[i]);
	printf("\nLIS의 길이 : %d", j + 1);
	return 0;
}